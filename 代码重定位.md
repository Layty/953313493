### 代码黑洞

程序在nor Flash上能读取，但不能写入，所以要将数据段放入允许读写sdram中。如果直接链接数据段到sdram的地址，这会导致bin文件很大，横跨nor flash到sdram。

解决方法如下：

- 第一个方法

1. 把数据段的g_Char和代码段靠在一起；
2. 烧写在Nor Flash上面；
3. 运行时把g_char(全局变量)复制到SDRAM，即0x3000000位置(重定位)；

- 第二个方法

1. 让文件直接从0x30000000开始，全局变量在0x3......；
2. 烧写Nor Flash上 0地址处；
3. 运行会把整个代码段数据段(整个程序)从0地址复制到SDRAM的0x30000000(重定位)；

这两个方法的区别是前者只重定位了数据段，后者重定位了数据段和代码段。





**elf文件格式**

1 链接得到elf文件，含有地址信息(load addr)

2 使用加载器



3 运行程序

4 如果loadaddr != runtimeaddr程序本身要重定位

核心程序运行时应该位于 runtimeaddr（reloate addr）或者链接地址

**bin文件**

1 elf生成bin文件

2 硬件机制启动

3 如果bin文件所在位置 不等于runtimeaddr ，程序本身实现重定位

bin文件/elf文件都不保存bss段 这些都是初始值为0 或者没有初始化的全局变量

程序运行时把bss段对应的空间清零

### 链接脚本格式

```
SECTIONS {
...
secname start BLOCK(align) (NOLOAD) : AT ( ldadr )
  { contents } >region :phdr =fill
...
}
```

```
secname  ：段名
start  ：起始地址：运行时的地址(runtime addr)；重定位地址(relocate addr)
AT ( ldadr ) ：可有可无(load addr:加载地址) 不写时LoadAddr = runtime addr
{ contents } 的内容举例如下：   代码段如果没有指定顺序，按照makefile的排序
start.o //内容为start.o文件
*（.text）所有的代码段文件
start.o *(.text)文件
```



#### 核心：

程序本身应该运行在  `runtime addr`,也就是 `relocate addr`,也就是链接地址

如果 bin 所在位置 ！= runtime addr，程序本身需要实现重定位



#### 分体式链接脚本

（jtag一般不支持，且需要 nor flash 或）   板子已经有FLASH，适用于单片机

```
SECTIONS {
   .text   0  : { *(.text) }
   .rodata  : { *(.rodata) }
   .data 0x30000000 : AT(0x700) 
   { 
      data_load_addr = LOADADDR(.data);
	  . = ALIGN(4);
      data_start = . ;
      *(.data) 
      data_end = . ;
   }
   
   . = ALIGN(4);//让当前地址向4对齐
   bss_start = .;
   .bss  : { *(.bss) *(.COMMON) }
   bss_end = .;
}
```

####  一体的链接脚本

```
SECTIONS
{
	. = 0x30000000;

	. = ALIGN(4);
	.text      :
	{
	  *(.text)
	}

	. = ALIGN(4);
	.rodata : { *(.rodata) }

	. = ALIGN(4);
	.data : { *(.data) }

	. = ALIGN(4);
	__bss_start = .;
	.bss : { *(.bss) *(.COMMON) }
	_end = .;
}
```

- bin文件/elf文件都不保存bss段 这些都是初始值为0 或者没有初始化的全局变量

- `3000005c:eb000106 bl 3000047c <sdram_init>  `反汇编中 bl 的地址是偏移地址，由pc+offset

- 使用 `Bl`或者`B`程序仍然在Sram 或者 Nor 必须使用 绝对地址跳转才能跳到SDRAM

- 重定位之前，不可使用绝对地址，不可以访问全局变量，静态变量，不可访问数组（rodata,data）,数组存放在只读数据段和数据段中，使用的时候放到栈中，数组的值用绝对地址访问，可以做一个然后看反汇编

  ```
  void sdram_init2(void)
  {
  	unsigned int arr[] = {
  		0x22000000, 	//BWSCON
  		0x00000700, 	//BANKCON0
  		0x00000700, 	//BANKCON1
  		0x00000700, 	//BANKCON2
  		0x00000700, 	//BANKCON3	
  		0x00000700, 	//BANKCON4
  		0x00000700, 	//BANKCON5
  		0x18001, 	//BANKCON6
  		0x18001, 	//BANKCON7
  		0x8404f5, 	//REFRESH,HCLK=12MHz:0x008e07a3,HCLK=100MHz:0x008e04f4
  		 0xb1,	//BANKSIZE
  		 0x20,	//MRSRB6
  		 0x20,	//MRSRB7

  		};
  	volatile unsigned int * p = (volatile unsigned int *)0x48000000;
  	int i;

  	for (i = 0; i < 13; i++)
  	{
  		*p = arr[i];
  		p++;
  	}
  	
  }
  ```

  ​

- 重定位之后，使用 ldr pc = runtime address ，如果使用b ，仍然没跳出去

- 位置无关码-----不使用绝对地址

https://sourceware.org/ml/binutils/2007-07/msg00154.html

http://www.100ask.org/bbs/forum.php?mod=viewthread&tid=16231&highlight=%C1%B4%BD%D3%BD%C5%B1%BE





C 编译程序的符号表 存放了变量的地址，链接脚本的值

1. 对于常规变量g_i，得到里面的值，使用&g_i得到addr；
2. 为了保持代码的一致，对于lds中的a1，使用&a1得到里面的值;
3. 结论：
   1. C程序中不保存lds文件中的变量，lds再大也不影响;

   2. 借助symbol table保存lds的变量，使用时加上"&"得到它的值，链接脚本的变量要在C程序中声明为外部变量，任何类型都可以；

      ```
      void clear_bss(void)
      {
      	extern int __bss_start, __bss_end;
      	int *p = &__bss_start;
      	
      	for (; p < &__bss_end; p++)
      		*p = 0;
      }
      ```

      ​